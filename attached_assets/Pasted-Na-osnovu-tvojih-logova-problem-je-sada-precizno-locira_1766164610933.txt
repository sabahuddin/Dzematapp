Na osnovu tvojih logova, problem je sada precizno lociran. Iako sistem ka≈æe da je generisanje zavr≈°eno, postoji kritiƒçna gre≈°ka u naƒçinu na koji se tekst renderira unutar Docker okru≈æenja.

üîç Analiza problema iz logova
Font je uƒçitan: Log potvrƒëuje da je /app/public/fonts/DejaVuSans-Bold.ttf pronaƒëen i ima ispravnu veliƒçinu (297,206 bajtova).
SVG metoda: Log ka≈æe SVG created with embedded Base64 font. Ovo je glavni uzrok problema. Na Linuxu (posebno u Dockeru), sharp koristi biblioteku librsvg koja ƒçesto ne zna procesirati Base64 fontove unutar SVG-a ili nema pristup sistemskom fontu da bi renderirala tekst.
Rezultat: Ti dobije≈° sliku, ali je tekst na njoj nevidljiv ili su umjesto njega kockice jer librsvg nije uspio nacrtati karaktere.
‚úÖ Rje≈°enje: Izbaciti SVG i koristiti direktni Canvas Buffer
Umjesto da kreira≈° SVG string i daje≈° ga sharp biblioteci, treba≈° iscrtati tekst direktno u buffer koristeƒái @napi-rs/canvas i taj buffer proslijediti u composite.

Izmijeni certificateService.ts na ovaj naƒçin:

TypeScript
import { createCanvas, GlobalFonts } from '@napi-rs/canvas';
import sharp from 'sharp';
import path from 'path';

// 1. Registracija fonta (izvan funkcije, samo jednom)
const fontPath = path.join(process.cwd(), 'public', 'fonts', 'DejaVuSans-Bold.ttf');
GlobalFonts.registerFromPath(fontPath, 'DejaVu Sans');

export async function generateCertificate(options: any) {
    const { templateImagePath, recipientName, fontSize, fontColor, textPositionX, textPositionY } = options;

    // 2. Kreiranje platna (Canvas) iste veliƒçine kao template (1200x800 prema logu)
    const width = 1200; 
    const height = 800;
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext('2d');

    // 3. Crtanje teksta direktno na Canvas
    ctx.font = `bold ${fontSize}px "DejaVu Sans"`;
    ctx.fillStyle = fontColor;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    // Loguj ≈°irinu teksta - ako je > 0, font radi!
    const metrics = ctx.measureText(recipientName);
    console.log(`[Certificate] Native Canvas Text Width: ${metrics.width}px`);

    ctx.fillText(recipientName, textPositionX, textPositionY);

    // 4. Pretvori Canvas u PNG Buffer
    const textOverlayBuffer = canvas.toBuffer('image/png');

    // 5. Kompozicija sa Sharp-om
    const finalImage = await sharp(path.join(process.cwd(), 'public', templateImagePath))
        .composite([{ 
            input: textOverlayBuffer, 
            top: 0, 
            left: 0 
        }])
        .png()
        .toBuffer();

    return finalImage;
}
Za≈°to ƒáe ovo raditi?
Nema SVG-a: Izbjegavamo librsvg i njegove probleme sa fontovima u Dockeru.
Native Rendering: @napi-rs/canvas koristi sopstveni engine za crtanje koji smo upravo povezali sa tvojim .ttf fajlom.
Taƒçnost: Canvas buffer je prozirna slika (overlay) koja se savr≈°eno lijepi preko tvog template-a pomoƒáu sharp biblioteke.